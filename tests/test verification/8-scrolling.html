<!-- Standalone Generated By Octo (octo-ide.com) -->
<script>data={"program":"# Scrolling test\n\n# This is a new test for this test suite, that allows you to test if your\n# scrolling opcodes do the right thing. All the arrows should land in their\n# boxes in the direction they point in.\n\n\n\n:stringmode str \"$0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ -.\" {\n  :byte { 4 * VALUE }\n}\n\n:macro text X Y STR {\n  vD := X\n  vE := Y\n  i := STR\n  drawText\n}\n\n:alias x vA\n:alias y vB\n\n: waitKeyRelease\n  v0 := 0\n: -\n  if v0 key then jump -\n  v0 += 1\n  if v0 == 16 then return\n  jump -\n\n# A cute little menu to select a test\n\n# Input:\n#  * v0 v1 point to 0xA + menu struct\n#  * v2 holds the length (zero-indexed)\n: menu-start\n  :alias cursorX v0\n  :alias cursorY v1\n  :alias numItems v2\n  :alias showing v3\n  :alias temp v4\n  :alias currentItem v5\n  :alias selectedItem v6\n\n  currentItem := 0\n  i := menu-draw-cursor\n  save v1\n  i := menu-choose-load\n  save v1\n  jump menu-draw-cursor\n: menu-move-cursor\n  if showing == 1 then sprite cursorX cursorY 2 # i should still be correct\n  waitKeyRelease\n: menu-draw-cursor\n  0 0 # i := <menu>\n  i += currentItem\n  i += currentItem\n  i += currentItem\n  i += currentItem\n  load cursorY # and cursorX\n  showing := 0\n  delay := showing\n\n  loop\n    # Blink cursor\n    temp := delay\n    if temp == 0 begin\n      i := menu-cursor\n      sprite cursorX cursorY 2\n      temp := 10\n      delay := temp\n      temp := 1\n      showing ^= temp\n    end\n\n    # Move cursor up\n    temp := 0xE\n    if temp key begin\n      if currentItem != 0 begin\n        currentItem -= 1\n        jump menu-move-cursor\n      end\n    end\n    # Move cursor down\n    temp := 0xF\n    if temp key begin\n      if currentItem != numItems begin\n        currentItem += 1\n        jump menu-move-cursor\n      end\n    end\n    # Start test under cursor\n    selectedItem := currentItem\n    temp := 0xA\n    if temp key then jump menu-choose\n\n    # Use numbers to jump to tests directly\n    temp := 0\n    numItems += 1\n    loop\n      temp += 1\n      if temp key begin\n        selectedItem := temp\n        selectedItem -= 1\n        jump menu-choose\n      end\n    if temp != numItems then again\n    numItems -= 1\n  again\n\n: menu-choose\n  waitKeyRelease\n: menu-choose-load\n  0 0 # i := <menu>\n  i += selectedItem\n  i += selectedItem\n  i += selectedItem\n  i += selectedItem\n  temp := 2\n  i += temp\n  load v1\n  temp := 0x10\n  v0 |= temp\n  i := menu-choose-jump\n  save v1\n: menu-choose-jump\n  0 0 # jump <item>\n\n# Font rendering code and character data\n# Kept this very simplistic and fast\n\n:macro drawCharacter REG {\n  if REG == 0 then return\n  v0 := REG\n  drawChar\n}\n\n: drawText\n  load vC\n  drawChar\n  drawCharacter v1\n  drawCharacter v2\n  drawCharacter v3\n  drawCharacter v4\n  drawCharacter v5\n  drawCharacter v6\n  drawCharacter v7\n  drawCharacter v8\n  drawCharacter v9\n  drawCharacter vA\n  drawCharacter vB\n  drawCharacter vC\n  return\n\n: drawChar\n  i := characters\n  i += v0\n  sprite vD vE 4\n  vD += 4\n  return\n\n\n: main\n  # Jump to the right test based on magic values\n  i := 0x1FF\n  load v0\n  if v0 == 1 then jump scrolling-superchip-lores-full-pixels\n  if v0 == 2 then jump scrolling-superchip-lores-half-pixels\n  if v0 == 3 then jump scrolling-superchip-hires\n  if v0 == 4 then jump scrolling-xochip-lores\n  if v0 == 5 then jump scrolling-xochip-hires\n\n\n\n: menu-1\n  lores\n  clear\n  text  6  2 scrolling-choose-1\n  text 12 12 scrolling-str-superchip\n  text 12 17 scrolling-str-xochip\n  render-version\n  :unpack 0xA scrolling-menu-1\n  v2 := 1\n  jump menu-start\n\n: menu-2\n  lores\n  clear\n  text  7  2 scrolling-choose-2\n  text 15 12 scrolling-str-lores\n  text 15 17 scrolling-str-hires\n  render-version\n  :unpack 0xA scrolling-menu-2\n  v2 := 1\n  jump menu-start\n\n: menu-3\n  lores\n  clear\n  text 10  2 scrolling-choose-3\n  text 18 12 scrolling-str-modern\n  text 18 17 scrolling-str-legacy\n  render-version\n  :unpack 0xA scrolling-menu-3\n  v2 := 1\n  jump menu-start\n\n: render-version\n  x := 50\n  y := 27\n  i := version-0-0\n  sprite x y 4\n  x := 58\n  i := version-1-0\n  sprite x y 4\n  return\n\n\n\n: scrolling-superchip\n  i := selection\n  v0 := 0\n  save v0\n  jump menu-2\n\n: scrolling-xochip\n  i := selection\n  v0 := 1\n  save v0\n  jump menu-2\n\n: scrolling-lores\n  i := selection\n  load v0\n  if v0 == 0 then jump menu-3\n  jump scrolling-xochip-lores\n\n: scrolling-hires\n  i := selection\n  load v0\n  if v0 == 0 then jump scrolling-superchip-hires\n  jump scrolling-xochip-hires\n\n\n\n: scrolling-superchip-lores-full-pixels\n\tclear\n\t\n  i := scrolling-arrow-left\n  v0 := 46\n  v1 := 11\n  sprite v0 v1 8\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\n  i := scrolling-arrow-right\n  v0 := 10\n  v1 := 11\n  sprite v0 v1 8\n\tscroll-right\n\tscroll-right\n\tscroll-right\n\n  i := scrolling-arrow-down\n  v0 := 28\n  v1 := 0\n  sprite v0 v1 8\n\tscroll-down 6\n\n  jump scrolling-draw-borders-lores\n\n: scrolling-superchip-lores-half-pixels\n\tclear\n\t\n  i := scrolling-arrow-left\n  v0 := 46\n  v1 := 11\n  sprite v0 v1 8\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n  scroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\n  i := scrolling-arrow-right\n  v0 := 10\n  v1 := 11\n  sprite v0 v1 8\n\tscroll-right\n\tscroll-right\n\tscroll-right\n  scroll-right\n\tscroll-right\n\tscroll-right\n\n  i := scrolling-arrow-down\n  v0 := 28\n  v1 := 0\n  sprite v0 v1 8\n\tscroll-down 12\n\n: scrolling-draw-borders-lores\n  i := scrolling-pixel\n  v0 := 21\t# X\n  v1 := 33\n  v2 := 27\n  v3 := 26\t# Y\n\tv4 := 15\n\tv5 := 4\n  loop\n    sprite v0 v3 1\n    sprite v1 v3 1\n\t\tsprite v0 v4 1\n    sprite v1 v4 1\n    sprite v2 v5 1\n    v0 += 1\n\t\tv1 += 1\n\t\tv2 += 1\n    if v0 != 31 then\n  again\n  v0 := 20  # X\n  v1 := 31\n  v2 := 32\n  v3 := 43\n\tv4 := 26\n\tv5 := 37\n\tv6 := 16  # Y\n\tv7 := 5\n  loop\n    sprite v0 v6 1\n    sprite v1 v6 1\n    sprite v2 v6 1\n\t\tsprite v3 v6 1\n\t\tsprite v4 v7 1\n\t\tsprite v5 v7 1\n    v6 += 1\n\t\tv7 += 1\n    if v6 != 26 then\n  again\n\n  v0 := key\n  waitKeyRelease\n  jump main\n\n\n: scrolling-superchip-hires\n\tclear\n\thires\n\t\n  i := scrolling-arrow-left\n  v0 := 78\n  v1 := 22\n  sprite v0 v1 8\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\n  i := scrolling-arrow-right\n  v0 := 42\n  v1 := 22\n  sprite v0 v1 8\n\tscroll-right\n\tscroll-right\n\tscroll-right\n\n  i := scrolling-arrow-down\n  v0 := 60\n  v1 := 11\n  sprite v0 v1 8\n\tscroll-down 12\n\n  i := scrolling-pixel\n  v0 := 53\t# X\n  v1 := 65\n  v2 := 59\n  v3 := 43\t# Y\n\tv4 := 32\n\tv5 := 21\n  loop\n    sprite v0 v3 1\n    sprite v1 v3 1\n\t\tsprite v0 v4 1\n    sprite v1 v4 1\n    sprite v2 v5 1\n    v0 += 1\n\t\tv1 += 1\n\t\tv2 += 1\n    if v0 != 63 then\n  again\n  v0 := 52  # X\n  v1 := 63\n  v2 := 64\n  v3 := 75\n\tv4 := 58\n\tv5 := 69\n\tv6 := 33  # Y\n\tv7 := 22\n  loop\n    sprite v0 v6 1\n    sprite v1 v6 1\n    sprite v2 v6 1\n\t\tsprite v3 v6 1\n\t\tsprite v4 v7 1\n\t\tsprite v5 v7 1\n    v6 += 1\n\t\tv7 += 1\n    if v7 != 32 then\n  again\n\n  v0 := key\n  waitKeyRelease\n  jump main\n\n\n\n: scrolling-xochip-lores\n\tclear\n\t\n  i := scrolling-arrow-left\n  v0 := 45\n  v1 := 23\n  sprite v0 v1 8\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\n  i := scrolling-arrow-right\n  v0 := 10\n  v1 := 12\n  sprite v0 v1 8\n\tscroll-right\n\tscroll-right\n\tscroll-right\n\n  i := scrolling-arrow-up\n  v0 := 22\n  v1 := 23\n  sprite v0 v1 8\n\tscroll-up 12\n\n  i := scrolling-arrow-down\n  v0 := 33\n  v1 := 0\n  sprite v0 v1 8\n\tscroll-down 6\n\n  i := scrolling-pixel\n  v0 := 21\t# X\n  v1 := 26\t# Y\n\tv2 := 15\n\tv3 := 4\n  loop\n    sprite v0 v1 1\n    sprite v0 v2 1\n\t\tsprite v0 v3 1\n    v0 += 1\n    if v0 != 42 then\n  again\n  v0 := 20  # X\n  v1 := 31\n  v2 := 42\n\tv3 := 5  # Y\n  loop\n    sprite v0 v3 1\n    sprite v1 v3 1\n    sprite v2 v3 1\n    v3 += 1\n    if v3 != 26 then\n  again\n\n  v0 := key\n  waitKeyRelease\n  jump main\n\n\n: scrolling-xochip-hires\n\tclear\n\thires\n\n  i := scrolling-arrow-left\n  v0 := 77\n  v1 := 46\n  sprite v0 v1 8\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\tscroll-left\n\n  i := scrolling-arrow-right\n  v0 := 42\n  v1 := 35\n  sprite v0 v1 8\n\tscroll-right\n\tscroll-right\n\tscroll-right\n\n  i := scrolling-arrow-up\n  v0 := 54\n  v1 := 46\n  sprite v0 v1 8\n\tscroll-up 12\n  scroll-up 12\n\n  i := scrolling-arrow-down\n  v0 := 65\n  v1 := 11\n  sprite v0 v1 8\n\tscroll-down 12\n\n  i := scrolling-pixel\n  v0 := 53\t# X\n  v1 := 21\t# Y\n\tv2 := 32\n\tv3 := 43\n  loop\n    sprite v0 v1 1\n    sprite v0 v2 1\n\t\tsprite v0 v3 1\n    v0 += 1\n    if v0 != 74 then\n  again\n  v0 := 52  # X\n  v1 := 63\n  v2 := 74\n\tv3 := 22  # Y\n  loop\n    sprite v0 v3 1\n    sprite v1 v3 1\n    sprite v2 v3 1\n    v3 += 1\n    if v3 != 43 then\n  again\n\n  v0 := key\n  waitKeyRelease\n  jump main\n\n\n\n: scratchpad\n  0\n: scratchpad-plus-1\n  0\n: scratchpad-plus-2\n  0 0 0 0 0\n  0 0 0 0 0\n  0 0 0 0\n: scratchpad-plus-16\n  0\n\n\n: menu-cursor\n  0b11000000\n  0b11000000\n\n\n# Positive and negative images\n: flag-ok\n  0b10100000\n  0b11000000\n: characters\n  0b10000000\n: flag-err\n  0b10100000\n  0b01000000\n  0b10100000\n\n# Individual characters, some taken from Corax89' test.\n: im0\n  0xE0 0xA0 0xA0 0xE0\n: im1\n  0xC0 0x40 0x40 0xE0\n: im2\n  0xE0 0x20 0xC0 0xE0\n: im3\n  0xE0 0x60 0x20 0xE0\n: im4\n  0xA0 0xE0 0x20 0x20\n: im5\n  0b11100000\n  0b11000000\n  0b00100000\n  0b11000000\n: im6\n  0xE0 0x80 0xE0 0xE0\n: im7\n  0xE0 0x20 0x20 0x20\n: im8\n  0xE0 0xE0 0xA0 0xE0\n: im9\n  0xE0 0xE0 0x20 0xE0\n: imA\n  0x40 0xA0 0xE0 0xA0\n: imB\n  0b11000000\n  0b11100000\n  0b10100000\n  0b11100000\n: imC\n  0b11100000\n  0b10000000\n  0b10000000\n  0b11100000\n: imD\n  0b11000000\n  0b10100000\n  0b10100000\n  0b11000000\n: imE\n  0xE0 0xC0 0x80 0xE0\n: imF\n  0xE0 0x80 0xC0 0x80\n: imG\n  0b01100000\n  0b10000000\n  0b10100000\n  0b01100000\n: imH\n  0b10100000\n  0b11100000\n  0b10100000\n  0b10100000\n: imI\n  0b11100000\n  0b01000000\n  0b01000000\n  0b11100000\n: imJ\n  0b01100000\n  0b00100000\n  0b00100000\n  0b11000000\n: imK\n  0b10100000\n  0b11000000\n  0b10100000\n  0b10100000\n: imL\n  0b10000000\n  0b10000000\n  0b10000000\n  0b11100000\n: imM\n  0b11100000\n  0b11100000\n  0b10100000\n  0b10100000\n: imN\n  0b11000000\n  0b10100000\n  0b10100000\n  0b10100000\n: imO\n  0b11100000\n  0b10100000\n  0b10100000\n  0b11100000\n: imP\n  0b11000000\n  0b10100000\n  0b11000000\n  0b10000000\n: imQ\n  0b01000000\n  0b10100000\n  0b11100000\n  0b01100000\n: imR\n  0b11000000\n  0b10100000\n  0b11000000\n  0b10100000\n: imS\n  0b01100000\n  0b11000000\n  0b00100000\n  0b11000000\n: imT\n  0b11100000\n  0b01000000\n  0b01000000\n  0b01000000\n: imU\n  0b10100000\n  0b10100000\n  0b10100000\n  0b01100000\n: imV\n  0b10100000\n  0b10100000\n  0b10100000\n  0b01000000\n: imW\n  0b10100000\n  0b10100000\n  0b11100000\n  0b11100000\n: imX\n  0xA0 0x40 0xA0 0xA0\n: imY\n  0b10100000\n  0b10100000\n  0b01000000\n  0b01000000\n: imZ\n  0b11100000\n  0b01100000\n  0b10000000\n  0b11100000\n: imSpace\n  0 0 0 0\n: imDash\n  0b00000000\n  0b11100000\n  0b00000000\n  0b00000000\n: imPeriod\n  0b00000000\n  0b00000000\n  0b00000000\n  0b01000000\n\n\n\n: scrolling-menu-1\n  8 13 :pointer scrolling-superchip\n  8 18 :pointer scrolling-xochip\n\n: scrolling-choose-1\n  str \"PICK PLATFORM\" 0\n: scrolling-str-superchip\n  str \"1 SUPERCHIP\" 0\n: scrolling-str-xochip\n  str \"2 XO-CHIP\" 0\n\n: scrolling-menu-2\n  11 13 :pointer scrolling-lores\n  11 18 :pointer scrolling-hires\n\n: scrolling-choose-2\n  str \"PICK SCR SIZE\" 0\n: scrolling-str-lores\n  str \"1 LOW RES\" 0\n: scrolling-str-hires\n  str \"2 HIGH RES\" 0\n\n: scrolling-menu-3\n  14 13 :pointer scrolling-superchip-lores-full-pixels\n  14 18 :pointer scrolling-superchip-lores-half-pixels\n\n: scrolling-choose-3\n  str \"PICK TARGET\" 0\n: scrolling-str-modern\n  str \"1 MODERN\" 0\n: scrolling-str-legacy\n  str \"2 LEGACY\" 0\n\n\n\n: scrolling-arrow-left\n  0b11111111\n  0b11100111\n  0b11001111\n  0b10000001\n  0b10000001\n  0b11001111\n  0b11100111\n  0b11111111\n\n: scrolling-arrow-right\n  0b11111111\n  0b11100111\n  0b11110011\n  0b10000001\n  0b10000001\n  0b11110011\n  0b11100111\n  0b11111111\n\n: scrolling-arrow-up\n  0b11111111\n  0b11100111\n  0b11000011\n  0b10000001\n  0b10100101\n  0b11100111\n  0b11100111\n  0b11111111\n\n: scrolling-arrow-down\n  0b11111111\n  0b11100111\n  0b11100111\n  0b10100101\n  0b10000001\n  0b11000011\n  0b11100111\n  0b11111111\n\n: scrolling-pixel\n  0b10000000\n\n: selection\n  0\n\n: version-0-0\n  0x0a 0xae 0xa2 0x42\n: version-1-0\n  0x10 0x30 0x10 0xb8\n\n\n","options":{"tickrate":20,"fillColor":"#FFCC00","fillColor2":"#FF6600","blendColor":"#662200","backgroundColor":"#996600","buzzColor":"#FFAA00","quietColor":"#000000","shiftQuirks":false,"loadStoreQuirks":false,"vfOrderQuirks":false,"clipQuirks":true,"jumpQuirks":false,"logicQuirks":true,"vBlankQuirks":true,"screenRotation":0,"maxSize":3216,"touchInputMode":"vip","fontStyle":"octo","displayScale":"6"},"rom":[19,12,96,0,224,161,18,4,112,1,64,16,0,238,18,4,101,0,162,34,241,85,162,130,241,85,18,34,67,1,208,18,34,2,0,0,245,30,245,30,245,30,245,30,241,101,99,0,243,21,244,7,52,0,18,68,165,231,208,18,100,10,244,21,100,1,131,67,100,14,228,158,18,82,69,0,18,82,117,255,18,28,100,15,228,158,18,96,149,32,18,96,117,1,18,28,134,80,100,10,228,161,18,128,100,0,114,1,116,1,228,158,18,120,134,64,118,255,18,128,84,32,18,108,114,255,18,50,34,2,0,0,246,30,246,30,246,30,246,30,100,2,244,30,241,101,100,16,128,65,162,154,241,85,0,0,252,101,35,2,65,0,0,238,128,16,35,2,66,0,0,238,128,32,35,2,67,0,0,238,128,48,35,2,68,0,0,238,128,64,35,2,69,0,0,238,128,80,35,2,70,0,0,238,128,96,35,2,71,0,0,238,128,112,35,2,72,0,0,238,128,128,35,2,73,0,0,238,128,144,35,2,74,0,0,238,128,160,35,2,75,0,0,238,128,176,35,2,76,0,0,238,128,192,35,2,0,238,165,235,240,30,221,228,125,4,0,238,161,255,240,101,64,1,19,202,64,2,19,250,64,3,20,134,64,4,21,2,64,5,21,106,0,254,0,224,109,6,110,2,166,147,34,156,109,12,110,12,166,161,34,156,109,12,110,17,166,173,34,156,35,150,96,166,97,139,98,1,18,16,0,254,0,224,109,7,110,2,166,191,34,156,109,15,110,12,166,205,34,156,109,15,110,17,166,215,34,156,35,150,96,166,97,183,98,1,18,16,0,254,0,224,109,10,110,2,166,234,34,156,109,18,110,12,166,246,34,156,109,18,110,17,166,255,34,156,35,150,96,166,97,226,98,1,18,16,106,50,107,27,167,42,218,180,106,58,167,46,218,180,0,238,167,41,96,0,240,85,19,74,167,41,96,1,240,85,19,74,167,41,240,101,64,0,19,112,21,2,167,41,240,101,64,0,20,134,21,106,0,224,167,8,96,46,97,11,208,24,0,252,0,252,0,252,0,252,0,252,0,252,167,16,96,10,97,11,208,24,0,251,0,251,0,251,167,32,96,28,97,0,208,24,0,198,20,58,0,224,167,8,96,46,97,11,208,24,0,252,0,252,0,252,0,252,0,252,0,252,0,252,0,252,0,252,0,252,0,252,0,252,167,16,96,10,97,11,208,24,0,251,0,251,0,251,0,251,0,251,0,251,167,32,96,28,97,0,208,24,0,204,167,40,96,21,97,33,98,27,99,26,100,15,101,4,208,49,209,49,208,65,209,65,210,81,112,1,113,1,114,1,48,31,20,72,96,20,97,31,98,32,99,43,100,26,101,37,102,16,103,5,208,97,209,97,210,97,211,97,212,113,213,113,118,1,119,1,54,26,20,108,240,10,34,2,19,12,0,224,0,255,167,8,96,78,97,22,208,24,0,252,0,252,0,252,0,252,0,252,0,252,167,16,96,42,97,22,208,24,0,251,0,251,0,251,167,32,96,60,97,11,208,24,0,204,167,40,96,53,97,65,98,59,99,43,100,32,101,21,208,49,209,49,208,65,209,65,210,81,112,1,113,1,114,1,48,63,20,196,96,52,97,63,98,64,99,75,100,58,101,69,102,33,103,22,208,97,209,97,210,97,211,97,212,113,213,113,118,1,119,1,55,32,20,232,240,10,34,2,19,12,0,224,167,8,96,45,97,23,208,24,0,252,0,252,0,252,0,252,0,252,0,252,167,16,96,10,97,12,208,24,0,251,0,251,0,251,167,24,96,22,97,23,208,24,0,220,167,32,96,33,97,0,208,24,0,198,167,40,96,21,97,26,98,15,99,4,208,17,208,33,208,49,112,1,48,42,21,68,96,20,97,31,98,42,99,5,208,49,209,49,210,49,115,1,51,26,21,88,240,10,34,2,19,12,0,224,0,255,167,8,96,77,97,46,208,24,0,252,0,252,0,252,0,252,0,252,0,252,167,16,96,42,97,35,208,24,0,251,0,251,0,251,167,24,96,54,97,46,208,24,0,220,0,220,167,32,96,65,97,11,208,24,0,204,167,40,96,53,97,21,98,32,99,43,208,17,208,33,208,49,112,1,48,74,21,176,96,52,97,63,98,74,99,22,208,49,209,49,210,49,115,1,51,43,21,196,240,10,34,2,19,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,192,160,192,128,160,64,160,224,160,160,224,192,64,64,224,224,32,192,224,224,96,32,224,160,224,32,32,224,192,32,192,224,128,224,224,224,32,32,32,224,224,160,224,224,224,32,224,64,160,224,160,192,224,160,224,224,128,128,224,192,160,160,192,224,192,128,224,224,128,192,128,96,128,160,96,160,224,160,160,224,64,64,224,96,32,32,192,160,192,160,160,128,128,128,224,224,224,160,160,192,160,160,160,224,160,160,224,192,160,192,128,64,160,224,96,192,160,192,160,96,192,32,192,224,64,64,64,160,160,160,96,160,160,160,64,160,160,224,224,160,64,160,160,160,160,64,64,224,96,128,224,0,0,0,0,0,224,0,0,0,0,0,64,8,13,3,166,8,18,3,174,104,76,52,84,148,104,88,44,120,64,100,112,92,0,8,148,116,124,104,60,112,52,72,76,104,0,12,148,136,100,152,52,72,76,104,0,11,13,3,182,11,18,3,192,104,76,52,84,148,116,52,112,148,116,76,144,60,0,8,148,88,100,132,148,112,60,116,0,12,148,72,76,68,72,148,112,60,116,0,14,13,3,202,14,18,3,250,104,76,52,84,148,120,44,112,68,60,120,0,8,148,92,100,56,60,112,96,0,12,148,88,60,68,44,52,140,0,255,231,207,129,129,207,231,255,255,231,243,129,129,243,231,255,255,231,195,129,165,231,231,255,255,231,231,165,129,195,231,255,128,0,10,174,162,66,16,48,16,184]}</script>
<script>"use strict";

function invertKeymap(k) {
	return Object.keys(k).reduce((a,b) => {
		Object.keys(k[b]).forEach(x => a[x]=+b)
		return a
	}, {})
}

function getPref(key) {
	try { return JSON.parse(localStorage.getItem(key)) }
	catch(e) { console.log(e); return null }
}
function setPref(key, value) {
	try { localStorage.setItem(key, JSON.stringify(value)) }
	catch(e) { console.log(e); }
}

var keymap = (this.STATIC_KEYMAP) || getPref('octoKeymap') || {
	0x0: { x:1 },
	0x1: { 1:1 },
	0x2: { 2:1 },
	0x3: { 3:1 },
	0x4: { q:1 },
	0x5: { w:1, ArrowUp:1 },
	0x6: { e:1, ' ':1 },
	0x7: { a:1, ArrowLeft:1 },
	0x8: { s:1, ArrowDown:1 },
	0x9: { d:1, ArrowRight:1 },
	0xA: { z:1 },
	0xB: { c:1 },
	0xC: { 4:1 },
	0xD: { r:1 },
	0xE: { f:1 },
	0xF: { v:1 },
}

var keymapInverse = invertKeymap(keymap)

var smallfonts = {
	octo: [
		0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
		0x20, 0x60, 0x20, 0x20, 0x70, // 1
		0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
		0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
		0x90, 0x90, 0xF0, 0x10, 0x10, // 4
		0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
		0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
		0xF0, 0x10, 0x20, 0x40, 0x40, // 7
		0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
		0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
		0xF0, 0x90, 0xF0, 0x90, 0x90, // A
		0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
		0xF0, 0x80, 0x80, 0x80, 0xF0, // C
		0xE0, 0x90, 0x90, 0x90, 0xE0, // D
		0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
		0xF0, 0x80, 0xF0, 0x80, 0x80, // F
	],
	vip: [
		0xF0, 0x90, 0x90, 0x90, 0xF0,
		0x60, 0x20, 0x20, 0x20, 0x70,
		0xF0, 0x10, 0xF0, 0x80, 0xF0,
		0xF0, 0x10, 0xF0, 0x10, 0xF0,
		0xA0, 0xA0, 0xF0, 0x20, 0x20,
		0xF0, 0x80, 0xF0, 0x10, 0xF0,
		0xF0, 0x80, 0xF0, 0x90, 0xF0,
		0xF0, 0x10, 0x10, 0x10, 0x10,
		0xF0, 0x90, 0xF0, 0x90, 0xF0,
		0xF0, 0x90, 0xF0, 0x10, 0xF0,
		0xF0, 0x90, 0xF0, 0x90, 0x90,
		0xF0, 0x50, 0x70, 0x50, 0xF0,
		0xF0, 0x80, 0x80, 0x80, 0xF0,
		0xF0, 0x50, 0x50, 0x50, 0xF0,
		0xF0, 0x80, 0xF0, 0x80, 0xF0,
		0xF0, 0x80, 0xF0, 0x80, 0x80,
	],
	dream6800: [
		0xE0, 0xA0, 0xA0, 0xA0, 0xE0,
		0x40, 0x40, 0x40, 0x40, 0x40,
		0xE0, 0x20, 0xE0, 0x80, 0xE0,
		0xE0, 0x20, 0xE0, 0x20, 0xE0,
		0x80, 0xA0, 0xA0, 0xE0, 0x20,
		0xE0, 0x80, 0xE0, 0x20, 0xE0,
		0xE0, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0xA0, 0xE0, 0xA0, 0xE0,
		0xE0, 0xA0, 0xE0, 0x20, 0xE0,
		0xE0, 0xA0, 0xE0, 0xA0, 0xA0,
		0xC0, 0xA0, 0xE0, 0xA0, 0xC0,
		0xE0, 0x80, 0x80, 0x80, 0xE0,
		0xC0, 0xA0, 0xA0, 0xA0, 0xC0,
		0xE0, 0x80, 0xE0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
	eti660: [
		0xE0, 0xA0, 0xA0, 0xA0, 0xE0,
		0x20, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0x20, 0xE0, 0x80, 0xE0,
		0xE0, 0x20, 0xE0, 0x20, 0xE0,
		0xA0, 0xA0, 0xE0, 0x20, 0x20,
		0xE0, 0x80, 0xE0, 0x20, 0xE0,
		0xE0, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0xA0, 0xE0, 0xA0, 0xE0,
		0xE0, 0xA0, 0xE0, 0x20, 0xE0,
		0xE0, 0xA0, 0xE0, 0xA0, 0xA0,
		0x80, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x80, 0x80, 0x80, 0xE0,
		0x20, 0x20, 0xE0, 0xA0, 0xE0,
		0xE0, 0x80, 0xE0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
	fish: [
		0x60, 0xA0, 0xA0, 0xA0, 0xC0,
		0x40, 0xC0, 0x40, 0x40, 0xE0,
		0xC0, 0x20, 0x40, 0x80, 0xE0,
		0xC0, 0x20, 0x40, 0x20, 0xC0,
		0x20, 0xA0, 0xE0, 0x20, 0x20,
		0xE0, 0x80, 0xC0, 0x20, 0xC0,
		0x40, 0x80, 0xC0, 0xA0, 0x40,
		0xE0, 0x20, 0x60, 0x40, 0x40,
		0x40, 0xA0, 0x40, 0xA0, 0x40,
		0x40, 0xA0, 0x60, 0x20, 0x40,
		0x40, 0xA0, 0xE0, 0xA0, 0xA0,
		0xC0, 0xA0, 0xC0, 0xA0, 0xC0,
		0x60, 0x80, 0x80, 0x80, 0x60,
		0xC0, 0xA0, 0xA0, 0xA0, 0xC0,
		0xE0, 0x80, 0xC0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
}
var bigfonts = {
	octo: [
		0xFF, 0xFF, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, // 0
		0x18, 0x78, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0xFF, // 1
		0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // 2
		0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 3
		0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, // 4
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 5
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 6
		0xFF, 0xFF, 0x03, 0x03, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x18, // 7
		0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 8
		0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 9
		0x7E, 0xFF, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xC3, // A
		0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, // B
		0x3C, 0xFF, 0xC3, 0xC0, 0xC0, 0xC0, 0xC0, 0xC3, 0xFF, 0x3C, // C
		0xFC, 0xFE, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFE, 0xFC, // D
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // E
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0  // F
	],
	schip: [
		0x3C, 0x7E, 0xE7, 0xC3, 0xC3, 0xC3, 0xC3, 0xE7, 0x7E, 0x3C,
		0x18, 0x38, 0x58, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C,
		0x3E, 0x7F, 0xC3, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xFF, 0xFF,
		0x3C, 0x7E, 0xC3, 0x03, 0x0E, 0x0E, 0x03, 0xC3, 0x7E, 0x3C,
		0x06, 0x0E, 0x1E, 0x36, 0x66, 0xC6, 0xFF, 0xFF, 0x06, 0x06,
		0xFF, 0xFF, 0xC0, 0xC0, 0xFC, 0xFE, 0x03, 0xC3, 0x7E, 0x3C,
		0x3E, 0x7C, 0xE0, 0xC0, 0xFC, 0xFE, 0xC3, 0xC3, 0x7E, 0x3C,
		0xFF, 0xFF, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x60,
		0x3C, 0x7E, 0xC3, 0xC3, 0x7E, 0x7E, 0xC3, 0xC3, 0x7E, 0x3C,
		0x3C, 0x7E, 0xC3, 0xC3, 0x7F, 0x3F, 0x03, 0x03, 0x3E, 0x7C,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // no hex chars!
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	],
	fish: [
		0x7C, 0xC6, 0xCE, 0xDE, 0xD6, 0xF6, 0xE6, 0xC6, 0x7C, 0x00, // at most 7x9 pixels!
		0x10, 0x30, 0xF0, 0x30, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00,
		0x78, 0xCC, 0xCC, 0x0C, 0x18, 0x30, 0x60, 0xCC, 0xFC, 0x00,
		0x78, 0xCC, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
		0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x1E, 0x00,
		0xFC, 0xC0, 0xC0, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
		0x38, 0x60, 0xC0, 0xC0, 0xF8, 0xCC, 0xCC, 0xCC, 0x78, 0x00,
		0xFE, 0xC6, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
		0x78, 0xCC, 0xCC, 0xEC, 0x78, 0xDC, 0xCC, 0xCC, 0x78, 0x00,
		0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x18, 0x18, 0x30, 0x70, 0x00,
		0x30, 0x78, 0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00,
		0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0xFC, 0x00,
		0x3C, 0x66, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x66, 0x3C, 0x00,
		0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00,
		0xFE, 0x62, 0x60, 0x64, 0x7C, 0x64, 0x60, 0x62, 0xFE, 0x00,
		0xFE, 0x66, 0x62, 0x64, 0x7C, 0x64, 0x60, 0x60, 0xF0, 0x00,
	],
	none: new Array(16*10).fill(0x00),
}
var fontsets = {
	octo     : { small: smallfonts.octo,      big: bigfonts.octo  },
	vip      : { small: smallfonts.vip,       big: bigfonts.none  },
	dream6800: { small: smallfonts.dream6800, big: bigfonts.none  },
	eti660   : { small: smallfonts.eti660,    big: bigfonts.none  },
	schip    : { small: smallfonts.octo,      big: bigfonts.schip },
	fish     : { small: smallfonts.fish,      big: bigfonts.fish  },
}

////////////////////////////////////
//
//   The Chip8 Interpreter:
//
////////////////////////////////////

function Emulator() {

	// persistent configuration settings
	this.tickrate           = 20;
	this.fillColor          = "#FFCC00";
	this.fillColor2         = "#FF6600";
	this.blendColor         = "#662200";
	this.backgroundColor    = "#996600";
	this.buzzColor          = "#FFAA00";
	this.quietColor         = "#000000";
	this.shiftQuirks        = false;
	this.loadStoreQuirks    = false;
	this.vfOrderQuirks      = false;
	this.clipQuirks         = false;
	this.jumpQuirks         = false;
	this.logicQuirks        = false;
	this.vBlankQuirks       = false;
	this.enableXO           = true;
	this.screenRotation     = 0;//must be 0, 90, 180, or 270
	this.maxSize            = 3584;
	this.touchInputMode     = 'none';
	this.maskFormatOverride = true;
	this.numericFormatStr   = "default";
	this.fontStyle          = 'octo';
	this.audioVolume        = 0.25;

	// interpreter state
	this.p  = [[],[]];  // pixels
	this.m  = [];       // memory (bytes)
	this.r  = [];       // return stack
	this.v  = [];       // registers
	this.pc = 0;        // program counter
	this.i  = 0;        // index register
	this.dt = 0;        // delay timer
	this.st = 0;        // sound timer
	this.pitch   = 64;  // audio pitch register
	this.pattern = [];  // audio pattern buffer
	this.hires = false; // are we in SuperChip high res mode?
	this.flags = [];    // semi-persistent hp48 flag vars
	this.plane = 1;     // graphics plane
	this.profile_data = {};

	// control/debug state
	this.keys = {};       // track keys which are pressed
	this.waiting = false; // are we waiting for a keypress?
	this.waitReg = -1;    // destination register of an awaited key
	this.halted = true;
	this.breakpoint = false;
	this.metadata = {};
	this.tickCounter = 0;
	this.linted = false;

	// external interface stubs
	this.exitVector  = function() {}                                                           // fired by 'exit'
	this.importFlags = function() { return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; } // load persistent flags
	this.exportFlags = function(flags) {}                                                      // save persistent flags
	this.buzzTimer   = function(timer) {}
	this.buzzBuffer  = function(buffer) {}
	this.buzzPitch   = function(pitch) {}

	this.init = function(rom) {
		// initialise memory with a new array to ensure that it is of the right size and is initiliased to 0
		this.m = this.enableXO ? new Uint8Array(0x10000) : new Uint8Array(0x1000);

		this.p = [[], []];
		if (this.enableXO)
			for(var z = 0; z < 64*128; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
		else
			for(var z = 0; z < 32*64; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }

		// initialize memory
		var font = fontsets[this.fontStyle];
		for(var z = 0; z < 32*64;            z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
		for(var z = 0; z < font.small.length;z++) { this.m[z] = font.small[z]; }
		for(var z = 0; z < font.big.length;  z++) { this.m[z + font.small.length] = font.big[z]; }
		for(var z = 0; z < rom.rom.length;   z++) { this.m[0x200+z] = rom.rom[z]; }
		for(var z = 0; z < 16;               z++) { this.v[z] = 0; }
		for(var z = 0; z < 16;               z++) { this.pattern[z] = 0; }

		// initialize interpreter state
		this.r = [];
		this.pc = 0x200;
		this.i  = 0;
		this.dt = 0;
		this.st = 0;
		this.pitch = 64;
		this.hires = false;
		this.plane = 1;

		// initialize control/debug state
		this.keys = {};
		this.waiting = false;
		this.waitReg = -1;
		this.halted = false;
		this.breakpoint = false;
		this.stack_breakpoint = -1;
		this.metadata = rom;
		this.tickCounter = 0;
		this.profile_data = {};
	}

	this.writeCarry = function(dest, value, flag) {
		this.v[dest] = (value & 0xFF);
		this.v[0xF] = flag ? 1 : 0;
		if (this.vfOrderQuirks) {
			this.v[dest] = (value & 0xFF);
		}
	}

	this.math = function(x, y, op) {
		// basic arithmetic opcodes
		switch(op) {
			case 0x0: this.v[x]  = this.v[y]; break;
			case 0x1: this.v[x] |= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x2: this.v[x] &= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x3: this.v[x] ^= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x4:
				var t = this.v[x]+this.v[y];
				this.writeCarry(x, t, (t > 0xFF));
				break;
			case 0x5:
				var t = this.v[x]-this.v[y];
				this.writeCarry(x, t, (this.v[x] >= this.v[y]));
				break;
			case 0x7:
				var t = this.v[y]-this.v[x];
				this.writeCarry(x, t, (this.v[y] >= this.v[x]));
				break;
			case 0x6:
				if (this.shiftQuirks) { y = x; }
				var t = this.v[y] >> 1;
				this.writeCarry(x, t, (this.v[y] & 0x1));
				break;
			case 0xE:
				if (this.shiftQuirks) { y = x; }
				var t = this.v[y] << 1;
				this.writeCarry(x, t, ((this.v[y] >> 7) & 0x1));
				break;
			default:
				haltBreakpoint("unknown math opcode "+op.toString(16).toUpperCase());
		}
	}

	this.misc = function(x, rest) {
		// miscellaneous opcodes
		switch(rest) {
			case 0x01: this.plane = (x & 0x3); break;
			case 0x02:
				for(var z = 0; z < 16; z++) this.pattern[z] = this.m[this.i+z];
				this.buzzBuffer(this.pattern); break;
			case 0x07: this.v[x] = this.dt; break;
			case 0x0A: this.waiting = true; this.waitReg = x; break;
			case 0x15: this.dt = this.v[x]; break;
			case 0x18: this.buzzTimer(this.st = this.v[x]); break;
			case 0x1E: this.i = (this.i + this.v[x])&0xFFFF; break;
			case 0x29: this.i = ((this.v[x] & 0xF) * 5); break;
			case 0x30: this.i = ((this.v[x] & 0xF) * 10 + fontsets[this.fontStyle].small.length); break;
			case 0x33:
				this.m[this.i]   = Math.floor(this.v[x]/100)%10;
				this.m[this.i+1] = Math.floor(this.v[x]/10)%10;
				this.m[this.i+2] = this.v[x]%10;
				break;
			case 0x3A: this.buzzPitch(this.pitch = this.v[x]); break;
			case 0x55:
				for(var z = 0; z <= x; z++) { this.m[this.i+z] = this.v[z]; }
				if (!this.loadStoreQuirks) { this.i = (this.i+x+1)&0xFFFF; }
				break;
			case 0x65:
				for(var z = 0; z <= x; z++) { this.v[z] = this.m[this.i+z]; }
				if (!this.loadStoreQuirks) { this.i = (this.i+x+1)&0xFFFF; }
				break;
			case 0x75:
				for(var z = 0; z <= x; z++) { this.flags[z] = this.v[z]; }
				this.exportFlags(this.flags);
				break;
			case 0x85:
				this.flags = this.importFlags();
				if (typeof this.flags == "undefined" || this.flags == null) {
					this.flags = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
				}
				for(var z = 0; z <= x; z++) { this.v[z] = 0xFF & this.flags[z]; }
				break;
			default:
				haltBreakpoint("unknown misc opcode "+rest.toString(16).toUpperCase());
		}
	}

	this.sprite = function sprite(x, y, len) {
		this.v[0xF] = 0x0;
		var rowSize = this.hires ? 128 : 64;
		var colSize = this.hires ?  64 : 32;
		var i = this.i;
		for(var layer = 0; layer < 2; layer++) {
			if ((this.plane & (layer+1)) == 0) { continue; }
			if (len == 0) {
				// draw a SuperChip 16x16 sprite
				for(var a = 0; a < 16; a++) {
					for(var b = 0; b < 16; b++) {
						var target = ((x+b) % rowSize) + ((y+a) % colSize)*rowSize;
						var source = ((this.m[i+(a*2)+(b > 7 ? 1:0)] >> (7-(b%8))) & 0x1) != 0;
						if (this.clipQuirks) {
							if ((x%rowSize)+b>=rowSize || (y%colSize)+a>=colSize) { source = 0; }
						}
						if (!source) { continue; }
						if (this.p[layer][target]) { this.p[layer][target] = 0; this.v[0xF] = 0x1; }
						else { this.p[layer][target] = 1; }
					}
				}
				i += 32;
			}
			else {
				// draw a Chip8 8xN sprite
				for(var a = 0; a < len; a++) {
					for(var b = 0; b < 8; b++) {
						var target = ((x+b) % rowSize) + ((y+a) % colSize)*rowSize;
						var source = ((this.m[i+a] >> (7-b)) & 0x1) != 0;
						if (this.clipQuirks) {
							if ((x%rowSize)+b>=rowSize || (y%colSize)+a>=colSize) { source = 0; }
						}
						if (!source) { continue; }
						if (this.p[layer][target]) { this.p[layer][target] = 0; this.v[0xF] = 0x1; }
						else { this.p[layer][target] = 1; }
					}
				}
				i += len;
			}
		}
	}

	this.call = function(nnn) {
		if (this.r.length >= 12) {
			haltBreakpoint("call stack overflow.");
		}
		this.r.push(this.pc);
		this.pc = nnn
	}

	this.jump0 = function(nnn) {
		if (this.jumpQuirks) { this.pc = nnn + this.v[(nnn >> 8)&0xF];  }
		else                 { this.pc = nnn + this.v[0]; }
	}

	this.machine = function(nnn) {
		if (nnn == 0x000) { this.halted = true; return; }
		haltBreakpoint("machine code is not supported.");
	}

	this.skip = function() {
		var op = (this.m[this.pc  ] << 8) | this.m[this.pc+1];
		this.pc += (op == 0xF000) ? 4 : 2;
	}

	this.opcode = function() {
		// Increment profilining data
		this.profile_data[this.pc] = (this.profile_data[this.pc] || 0) + 1;

		// decode the current opcode
		var op  = (this.m[this.pc  ] << 8) | this.m[this.pc+1];
		var o   = (this.m[this.pc  ] >> 4) & 0x00F;
		var x   = (this.m[this.pc  ]     ) & 0x00F;
		var y   = (this.m[this.pc+1] >> 4) & 0x00F;
		var n   = (this.m[this.pc+1]     ) & 0x00F;
		var nn  = (this.m[this.pc+1]     ) & 0x0FF;
		var nnn = op & 0xFFF;
		this.pc += 2;

		// execute a simple opcode
		if (op == 0x00E0) {
			// clear
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = 0; z < this.p[layer].length; z++) {
					this.p[layer][z] = 0;
				}
			}
			return;
		}
		if (op == 0x00EE) {
			// return
			this.pc = this.r.pop();
			return;
		}
		if ((op & 0xF0FF) == 0xE09E) {
			// if -key
			if (Object.keys(keymap[this.v[x]]||{}).some(x => x in this.keys)) { this.skip(); }
			return;
		}
		if ((op & 0xF0FF) == 0xE0A1) {
			// if key
			if (!Object.keys(keymap[this.v[x]]||{}).some(x => x in this.keys)) { this.skip(); }
			return;
		}
		if ((op & 0xFFF0) == 0x00C0) {
			// scroll down n pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = this.p[layer].length - 1; z >= 0; z--) {
					this.p[layer][z] = (z >= rowSize * n) ? this.p[layer][z - (rowSize * n)] : 0;
				}
			}
			return;
		}
		if ((op & 0xFFF0) == 0x00D0) {
			// scroll up n pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = 0; z < this.p[layer].length; z++) {
					this.p[layer][z] = (z < (this.p[layer].length - rowSize * n)) ? this.p[layer][z + (rowSize * n)] : 0;
				}
			}
			return;
		}
		if (op == 0x00FB) {
			// scroll right 4 pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var a = 0; a < this.p[layer].length; a += rowSize) {
					for(var b = rowSize-1; b >= 0; b--) {
						this.p[layer][a + b] = (b > 3) ? this.p[layer][a + b - 4] : 0;
					}
				}
			}
			return;
		}
		if (op == 0x00FC) {
			// scroll left 4 pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var a = 0; a < this.p[layer].length; a += rowSize) {
					for(var b = 0; b < rowSize; b++) {
						this.p[layer][a + b] = (b < rowSize - 4) ? this.p[layer][a + b + 4] : 0;
					}
				}
			}
			return;
		}
		if (op == 0x00FD) {
			// exit
			this.halted = true;
			this.exitVector();
			return;
		}
		if (op == 0x00FE) {
			// lores
			this.hires = false;
			this.p = [[], []];
			for(var z = 0; z < 32*64; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
			return;
		}
		if (op == 0x00FF) {
			// hires
			this.hires = true;
			this.p = [[], []];
			for(var z = 0; z < 64*128; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
			return;
		}
		if (op == 0xF000) {
			// long memory reference
			this.i = ((this.m[this.pc] << 8) | (this.m[this.pc+1])) & 0xFFFF;
			this.pc += 2;
			return;
		}

		if (o == 0x5 && n != 0) {
			if (n == 2) {
				// save range
				var dist = Math.abs(x - y);
				if (x < y) { for(var z = 0; z <= dist; z++) { this.m[this.i+z] = this.v[x+z]; }}
				else       { for(var z = 0; z <= dist; z++) { this.m[this.i+z] = this.v[x-z]; }}
				return;
			}
			else if (n == 3) {
				// load range
				var dist = Math.abs(x - y);
				if (x < y) { for(var z = 0; z <= dist; z++) { this.v[x+z] = this.m[this.i+z]; }}
				else       { for(var z = 0; z <= dist; z++) { this.v[x-z] = this.m[this.i+z]; }}
				return;
			}
			else {
				haltBreakpoint("unknown opcode "+op.toString(16).toUpperCase());
			}
		}
		if (o == 0x9 && n != 0) {
			haltBreakpoint("unknown opcode "+op.toString(16).toUpperCase());
		}

		// dispatch complex opcodes
		switch(o) {
			case 0x0: this.machine(nnn);                            break;
			case 0x1: this.pc = nnn;                                break;
			case 0x2: this.call(nnn);                               break;
			case 0x3: if (this.v[x] == nn)        { this.skip(); }  break;
			case 0x4: if (this.v[x] != nn)        { this.skip(); }  break;
			case 0x5: if (this.v[x] == this.v[y]) { this.skip(); }  break;
			case 0x6: this.v[x] = nn;                               break;
			case 0x7: this.v[x] = (this.v[x] + nn) & 0xFF;          break;
			case 0x8: this.math(x, y, n);                           break;
			case 0x9: if (this.v[x] != this.v[y]) { this.skip(); }  break;
			case 0xA: this.i = nnn;                                 break;
			case 0xB: this.jump0(nnn);                              break;
			case 0xC: this.v[x] = (Math.random()*256)&nn;           break;
			case 0xD: this.sprite(this.v[x], this.v[y], n);         break;
			case 0xF: this.misc(x, nn);                             break;
			default: haltBreakpoint("unknown opcode "+o.toString(16).toUpperCase());
		}
	}

	this.tick = function() {
		if (this.halted) { return; }
		this.tickCounter++;
		try {
			this.opcode();
		}
		catch(err) {
			console.log("halted: " + err);
			this.halted = true;
		}
	}
}
</script>
<script>"use strict";

////////////////////////////////////
//
//   Emulator Execution
//
////////////////////////////////////

//must be set > 0
var scaleFactor = 5;
//dom id for canvas element
var renderTarget = "target";

const optionFlags = [
	"tickrate",
	"fillColor",
	"fillColor2",
	"blendColor",
	"backgroundColor",
	"buzzColor",
	"quietColor",
	"shiftQuirks",
	"loadStoreQuirks",
	"vfOrderQuirks",
	"clipQuirks",
	"vBlankQuirks",
	"jumpQuirks",
	"screenRotation",
	"maxSize",
	"touchInputMode",
	"logicQuirks",
	"fontStyle",
	"audioVolume",
]
function unpackOptions(emulator, options) {
	optionFlags.forEach(x => { if (x in options) emulator[x] = options[x] })
	if (options["enableXO"]) emulator.maxSize = 65024 // legacy option
}
function packOptions(emulator) {
	const r = {}
	optionFlags.forEach(x => r[x] = emulator[x])
	return r
}

function setRenderTarget(scale, canvas) {
	scaleFactor = scale;
	renderTarget = canvas;
	var c = document.getElementById(canvas);

	// Remove any existing previous delta frame so first frame is always drawn:
	c.last = undefined;

	var w  = scaleFactor * 128;
	var h  = scaleFactor *  64;

	if (emulator.screenRotation == 90 || emulator.screenRotation == 270) {
		c.width  = h;
		c.height = w;
	}
	else {
		c.width  = w;
		c.height = h;
	}
}

function setTransform(emulator, g) {
	g.setTransform(1, 0, 0, 1, 0, 0);
	var x = scaleFactor * 128;
	var y = scaleFactor *  64;
	switch(emulator.screenRotation) {
		case 90:
			g.rotate(0.5 * Math.PI);
			g.translate(0, -y);
			break;
		case 180:
			g.rotate(1.0 * Math.PI);
			g.translate(-x, -y);
			break;
		case 270:
			g.rotate(1.5 * Math.PI);
			g.translate(-x, 0);
			break;
		default:
			console.assert(emulator.screenRotation === 0, 'Screen rotation not set to 0, 90, 180, or 270. Treating as 0.')
	}
}


function arrayEqual(a, b) {
	var length = a.length;
	if (length !== b.length) { return false; }
	for (var i = 0; i < length; i++) {
		if (a[i] !== b[i]) { return false; }
	}
	return true;
}

function getColor(id) {
	switch(id) {
		case 0: return emulator.backgroundColor;
		case 1: return emulator.fillColor;
		case 2: return emulator.fillColor2;
		case 3: return emulator.blendColor;
	}
	throw "invalid color: " + id;
}

function renderDisplay(emulator) {
	var c = document.getElementById(renderTarget);

	// Canvas rendering can be expensive. Exit out early if nothing has changed.
	var colors = [emulator.backgroundColor, emulator.fillColor, emulator.fillColor2, emulator.blendColor];
	if (c.last !== undefined) {
		if (arrayEqual(c.last.p[0], emulator.p[0]) && arrayEqual(c.last.p[1], emulator.p[1])
				&& arrayEqual(c.last.colors, colors)) {
			return;
		}
		if (c.last.hires !== emulator.hires)
			c.last = undefined;  // full redraw when switching resolution
	}
	var g = c.getContext("2d");
	setTransform(emulator, g);
	var w      = emulator.hires ? 128         : 64;
	var h      = emulator.hires ? 64          : 32;
	var size   = emulator.hires ? scaleFactor : scaleFactor*2;
	var lastPixels = c.last !== undefined? c.last.p: [[], []]

	g.scale(size, size)
	var z = 0;
	for(var y = 0; y < h; ++y) {
		for(var x = 0; x < w; ++x, ++z) {
			var oldColorIdx = lastPixels[0][z] + (lastPixels[1][z] << 1);
			var colorIdx = emulator.p[0][z] + (emulator.p[1][z] << 1);
			if (oldColorIdx !== colorIdx) {
				g.fillStyle = getColor(colorIdx);
				g.fillRect(x, y, 1, 1);
			}
		}
	}
	g.scale(1, 1) //restore scale to 1,1 just in case

	c.last = {
		colors: colors,
		p: [emulator.p[0].slice(), emulator.p[1].slice()],
		hires: emulator.hires,
	};
}

////////////////////////////////////
//
//   Audio Playback
//
////////////////////////////////////

var audio;
var audioNode;
var audioSource;
var audioData;
var XOAudio;

var AudioBuffer = function(buffer, duration) {
	if (!(this instanceof AudioBuffer)) {
		return new AudioBuffer(buffer, duration);
	}

	this.pointer = 0;
	this.buffer = buffer;
	this.duration = duration;
}

AudioBuffer.prototype.write = function(buffer, index, size) {
	size = Math.max(0, Math.min(size, this.duration))
	if (!size) { return size; }

	this.duration -= size;
	var bufferSize = this.buffer.length;
	var end = index + size;

	for(var i = index; i < end; ++i) {
		buffer[i] = this.buffer[this.pointer++];
		this.pointer %= bufferSize;
	}

	return size;
}

AudioBuffer.prototype.dequeue = function(duration) {
	this.duration -= duration;
}

var FREQ = 4000;
var PITCH_BIAS = 64;

function audioEnable() {
	// this will only work if called directly from a user-generated input handler:
	if (audio && audio.state == 'suspended') audio.resume()
}

function audioSetup(emulator) {
	if (!audio) {
		if (typeof AudioContext !== 'undefined') {
			audio = new AudioContext();
		}
		else if (typeof webkitAudioContext !== 'undefined') {
			audio = new webkitAudioContext();
		}
	}
	audioEnable()
	if (audio && !audioNode) {
		const bufferSize = // set bufferSize according to environment's samplerate
		audio.sampleRate <  64000 ? 2048 : // for 48000hz or 44100hz or less
		audio.sampleRate < 128000 ? 4096 : 8192; // for 96000hz or more
		audioNode = audio.createScriptProcessor(bufferSize, 1, 1);
		audioNode.gain = audio.createGain();
		audioNode.gain.gain.value = emulator.audioVolume
		audioNode.onaudioprocess = function(audioProcessingEvent) {
			var outputBuffer = audioProcessingEvent.outputBuffer;
			var outputData = outputBuffer.getChannelData(0);
			var samples_n = outputBuffer.length;
			var index = 0;
			while(audioData.length && index < samples_n) {
				var size = samples_n - index;
				var written = audioData[0].write(outputData, index, size);
				index += written;
				if (written < size) {
					audioData.shift();
				}
			}

			while(index < samples_n) {
				outputData[index++] = 0;
			}
			//the last one can be long sound with high value of buzzer, so always keep it
			if (audioData.length > 1) {
				var audioDataSize = 0;
				var audioBufferSize = audioNode.bufferSize;
				audioData.forEach(function(buffer) { audioDataSize += buffer.duration; })
				while(audioDataSize > audioBufferSize && audioData.length > 1) {
					audioDataSize -= audioData.shift().duration;
				}
			}
		}
		audioData = [];
		audioNode.connect(audioNode.gain);
		audioNode.gain.connect(audio.destination);

		XOAudio = new AudioControl();
		emulator.buzzTimer  = _ => XOAudio.setTimer(_);
		emulator.buzzBuffer = _ => XOAudio.setBuffer(_);
		emulator.buzzPitch  = _ => XOAudio.setPitch(_);
	}
	return audio && audioNode
}

function stopAudio() {
	if (!audio) { return; }
	if (audioNode) {
		audioNode.disconnect();
		audioNode = null;
	}
	audioData = [];
}

function playPattern(soundLength,buffer,pitch=PITCH_BIAS,
	sampleState={ pos: 0 }) {
	if (!audio) { return; }
	audioEnable()

	var freq = FREQ*2**((pitch-PITCH_BIAS)/48);
	var samples = Math.ceil(audio.sampleRate * soundLength);
	
	var bufflen = buffer.length * 8;
	var audioBuffer = new Float32Array(samples);

	var step = freq / audio.sampleRate;
	var pos = sampleState.pos;

	// keep super-sampling consistent with audio sample rate
	var quality = Math.ceil( 384000 / audio.sampleRate );
	var lowPassAlpha = getLowPassAlpha(audio.sampleRate * quality);
	
	for(var i = 0, il = samples; i < il; i++) {
		for (var j = 0; j < quality; ++j) {
			var cell = pos >> 3, shift = pos & 7 ^ 7;
			var value = getLowPassFilteredValue(lowPassAlpha, buffer[cell] >> shift & 1);
			pos = ( pos + step/quality ) % bufflen;
		}
		audioBuffer[i] = value;
	}

	audioData.push(new AudioBuffer(audioBuffer, samples));
	
	return { pos };
}

const silentPattern = new Array(64).fill(0);

function AudioControl(){
	this.state = { pos: 0 };
	this.reset = true;
	this.buffer = [];

	this.timer = 0;
	this.pitch = PITCH_BIAS;

	this.refresh = _ => {
		if (this.reset) this.state.pos = 0; this.reset = false;
		if (this.timer == 0) playPattern(_,silentPattern);
		else this.state = playPattern(_,this.buffer,this.pitch,this.state);
		if((this.timer -= this.timer>0) == 0) this.reset = true;
		while(audioData.length > 8) audioData.shift();
	}
	this.setTimer = (timer) => {
		if(timer == 0) this.reset = true;
		this.timer = timer;
	}
	this.setBuffer = buffer => this.buffer = buffer;
	this.setPitch = pitch => this.pitch = pitch;
}

function escapeHtml(str) {
    var div = document.createElement('div');
    div.appendChild(document.createTextNode(str));
    return div.innerHTML;
}

// Should be a good way below the Nyquist limit of 22.05 kHz.
const cutoffFrequency = 18000;

// How many filters to put in sequence.
const lowPassFilterSteps = 4;

// Each filter is an exponential filter, which mimics a simple analog RC filter.
// We need multiple of them in series to get decent attenuation near the stop band.

const lowPassBuffer = new Array(lowPassFilterSteps + 1).fill(0);

function getLowPassAlpha(samplingFrequency) {
	const c = Math.cos(2 * Math.PI * cutoffFrequency / samplingFrequency);
	return c - 1 + Math.sqrt(c * c - 4 * c + 3);
}

function getLowPassFilteredValue(alpha, targetValue) {
	lowPassBuffer[0] = targetValue;
	for (let i = 1; i < lowPassBuffer.length; ++i) {
		lowPassBuffer[i] += (lowPassBuffer[i - 1] - lowPassBuffer[i]) * alpha;
	}
	return lowPassBuffer[lowPassBuffer.length - 1];
}
</script>
<script>/**
* Adaptive Input
**/

const ael = (element, event, listener) => element.addEventListener   (event, listener, { passive:false })
const rel = (element, event, listener) => element.removeEventListener(event, listener, { passive:false })
const pd  = event => (event.preventDefault(),event.stopPropagation())

function addPointer(element,start,move,end){
  function mouseToTouch(f){
    return event=>{
      const to={indentifier:1,target:element,clientX:event.clientX,clientY:event.clientY}
      f({changedTouches:[to],touches:[to],preventDefault:_=>{},stopPropagation:_=>{}})
    }
  }
  let mousedown=false
  const events={
    touchstart: start,
    touchmove:  move,
    touchend:   end,
    mousedown:  mouseToTouch(e=>{mousedown=true;start(e)}),
    mousemove:  mouseToTouch(e=>{if(mousedown)move(e)}),
    mouseup:    mouseToTouch(e=>{mousedown=false;end(e)}),
    mouseout:   mouseToTouch(e=>{mousedown=false;end(e)}),
  }
  Object.keys(events).forEach(k=>ael(element,k,events[k]))
  return _=>{Object.keys(events).forEach(k=>rel(element,k,events[k]))}
}

const VIP_HEX  = '123c456d789ea0bf'.split('')
const VIP_KEYS = VIP_HEX.map(x => parseInt(x,16))

const GAMEPAD_STYLES = `
.gamepad{
  position:absolute;
  top:10%;
  left:0px;
  width:100%;
  height:90%;
  opacity:0.3;
  user-select: none;
  -webkit-user-select: none;
}
.gamepad .dpad{
  position:absolute;
  bottom: 50px;
  left:   50px;
  width:  250px;
  height: 250px;
  background: gray;
  border-radius: 50%;
  overflow:hidden;
}
.gamepad .stick{
  display:none;
  position:absolute;
  border-radius: 50%;
  width:100px;
  height:100px;
  margin-left:-50px;
  margin-top:-50px;
}
.gamepad .buttons{
  position:absolute;
  bottom: 50px;
  right:  50px;
  width:  250px;
  height: 250px;
}
.gamepad .gamebutton{
  position:absolute;
  width:  125px;
  height: 125px;
  background:gray;
  border-radius:50%;
  overflow:hidden;
  line-height: 125px;
  font-size:50px;
  font-weight:bold;
  color:darkgray;
  text-align:center;
}
.gamepad .dpad.active .stick {display:block;background:#444}
.gamepad .gamebutton.active{background:#444;}
.gamepad .gamebutton.b{left:0;bottom:0;}
.gamepad .gamebutton.a{right:0;top:0;}
`
const VIP_STYLES = `
.vip-pad {display:flex;flex-direction:column;align-items:center;z-index:2000;}
.vip-pad .keypad {display:flex;flex-direction:column;margin-top:10px;}
.vip-pad .keypad>div {display:flex;flex-direction:row;}
.vip-pad .keypad>div>div {
  -webkit-user-select: none;
  user-select: none;
  background:gray;
  width: 100px;
  height: 51px;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 1px;
}
.vip-pad .keypad>div>div:active,
.vip-pad .keypad>div>div.active {background:black; border:1px solid white;margin:0px;}
`

const INPUT_MODULES = {
  /**
  * An invisible set of gesture recognizers,
  * giving directional input and an action for taps.
  **/
  swipe: {
    install: (screen,up,down,options) => {

      let vdirs      = []
      let direction  = { i:null, sx:0, sy:0, lx:0, ly:0 }
      let action1    = {}
      let taptimeout = null

      const updateStick = _ => {
        // find the relative position of the stick to its starting point
        const cx = direction.lx - direction.sx
        const cy = direction.ly - direction.sy

        // update the virtual direction buttons
        let t = []
        const DEAD_ZONE = 30
        if (Math.abs(cx) > DEAD_ZONE) t.push(cx < 0 ? options.left : options.right)
        if (Math.abs(cy) > DEAD_ZONE) t.push(cy < 0 ? options.up   : options.down)
        vdirs.forEach(x => (t    .indexOf(x)<0) && up  (x)) // clear keys no longer held
        t    .forEach(x => (vdirs.indexOf(x)<0) && down(x)) // push keys that were not held before
        vdirs = t
      }
      const tapDown= i => {
        if (Object.keys(action1).length == 0) down(options.action1)
        action1[i] = true
        if (i == direction.i) { direction = { i:null, sx:0, sy:0, lx:0, ly:0 } }
        taptimeout = null
      }
      const start = e => {
        const t = e.touches[0]
        const i = t.identifier
        // a single-touch is either directional or a tap...
        if (direction.i != null) {
          tapDown(i)
        }
        else {
          direction.i  = i
          direction.sx = t.clientX
          direction.sy = t.clientY
          direction.lx = t.clientX
          direction.ly = t.clientY
          taptimeout = setTimeout(_ => tapDown(i), 100)
        }
        updateStick(),pd(e)
      }
      const move = e => {
        for(let z = 0; z < e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i == direction.i) {
            if (taptimeout != null) { clearTimeout(taptimeout); taptimeout = null }
            direction.lx = t.clientX
            direction.ly = t.clientY
          }
        }
        updateStick(),pd(e)
      }
      const end = e => {
        let r1 = false
        for(let z = 0; z < e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i == direction.i) {
            if (taptimeout != null) {
              // cancel a short tap
              clearTimeout(taptimeout); taptimeout = null
              down(options.action1)
              setTimeout(_ => up(options.action1), 50)
            }
            direction = { i:null, sx:0, sy:0, lx:0, ly:0 }
          }
          if (i in action1) {
            delete action1[i]
            r1=true
          }
        }
        if (r1 && Object.keys(action1).length == 0) up(options.action1)
        updateStick(),pd(e)
      }
      ael(screen, 'touchstart', start)
      ael(screen, 'touchmove',  move)
      ael(screen, 'touchend',   end)
      screen.uninstallSwipe = _ => {
        rel(screen, 'touchstart', start)
        rel(screen, 'touchmove',  move)
        rel(screen, 'touchend',   end)
      }
    },
    remove: (screen) => {
      if(screen.uninstallSwipe)screen.uninstallSwipe()
      delete screen.uninstallSwipe
    }
  },

  /**
  * A virtual gamepad overlay with two remappable action keys.
  **/
  gamepad: {
    install: (screen,up,down,options) => {
      // build the UI
      if (document.querySelector('.gamepad')) return
      const root = document.createElement('div')
      root.classList.add('gamepad')
      root.innerHTML = `
      <div class='dpad'><div class='stick'></div></div>
      <div class='buttons'><div class='gamebutton b'>B</div><div class='gamebutton a'>A</div></div>
      <style>${GAMEPAD_STYLES}</style>`
      screen.parentElement.append(root)

      let vdirs      = []
      let directions = {}
      let buttons    = {}
      const pad   = document.querySelector('.gamepad .dpad')
      const stick = document.querySelector('.gamepad .dpad .stick')
      const a     = document.querySelector('.gamepad .gamebutton.a')
      const b     = document.querySelector('.gamepad .gamebutton.b')

      const updateStick = _ => {
        // find centroid of d-pad touchpoints ({0,0} if no touchpoints)
        const touches = Object.values(directions)
        let cx = 0, cy = 0, r = pad.getBoundingClientRect(), sr = stick.getBoundingClientRect()
        touches.forEach(t => (cx+=t.x, cy+=t.y))
        cx /= touches.length,         cy /= touches.length
        cx -= (r.left + (r.width/2)), cy -= (r.top + (r.height/2))

        // position the virtual stick, clamped within dpad
        const ca = Math.atan2(cy, cx)
        const cd = Math.min(Math.sqrt(cx*cx + cy*cy), (r.width/2)-(sr.width/2))
        stick.style.left = ((Math.cos(ca)*cd)+(r.width /2)|0)+'px'
        stick.style.top  = ((Math.sin(ca)*cd)+(r.height/2)|0)+'px'

        // update the virtual direction buttons
        let t = []
        const DEAD_ZONE = 30
        if (Math.abs(cx) > DEAD_ZONE) t.push(cx < 0 ? options.left : options.right)
        if (Math.abs(cy) > DEAD_ZONE) t.push(cy < 0 ? options.up   : options.down)
        vdirs.forEach(x => (t    .indexOf(x)<0) && up  (x)) // clear keys no longer held
        t    .forEach(x => (vdirs.indexOf(x)<0) && down(x)) // push keys that were not held before
        vdirs = t
      }

      const start = e => {
        for(let z = 0; z<e.touches.length; z++) {
          const t = e.touches[z]
          const i = t.identifier
          if (t.target == a) {
            t.target.classList.add('active')
            buttons[i]=options.action1
            down(options.action1)
          }
          if (t.target == b) {
            t.target.classList.add('active')
            buttons[i]=options.action2
            down(options.action2)
          }
          if (t.target == pad) {
            t.target.classList.add('active')
            directions[i]={x:t.clientX, y:t.clientY}
          }
        }
        updateStick(),pd(e)
      }
      const move = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i in directions) directions[i]={x:t.clientX, y:t.clientY}
        }
        updateStick(),pd(e)
      }
      const end = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i in buttons) {
            t.target.classList.remove('active')
            up(buttons[i])
            delete buttons[i]
          }
          if (i in directions) {
            t.target.classList.remove('active')
            delete directions[i]
          }
        }
        updateStick(),pd(e)
      }

      ael(a,   'touchstart', start)
      ael(a,   'touchend',   end  )
      ael(b,   'touchstart', start)
      ael(b,   'touchend',   end  )
      ael(pad, 'touchstart', start)
      ael(pad, 'touchmove',  move )
      ael(pad, 'touchend',   end  )
    },
    remove: (screen) => {
      document.querySelector('.gamepad').remove()
    },
  },

  /**
  * Treat the entire screen, or a centered square region, as invisible buttons,
  * mapped out in the order of the VIP hex keypad.
  **/
  seg16: {
    install: (screen,up,down,options) => {
      const tmap = {}
      const pointToKey = touch => {
        // poll this for each point, as it may vary over time,
        // and experimentally it's never right initially...
        const r = screen.getBoundingClientRect()
        if (options.mode == 'center') {
          if (r.width > r.height) { r.x += (r.width - r.height)/2; r.width = r.height }
          else                    { r.y += (r.height - r.width)/2; r.height = r.width }
        }
        const x = touch.clientX - r.x
        const y = touch.clientY - r.y
        if (x < 0 || x > r.width || y < 0 || y > r.height) return null
        const tx = Math.floor(x / (r.width /4))
        const ty = Math.floor(y / (r.height/4))
        return VIP_KEYS[tx + (4 * ty)]
      }
      const start = e => {
        for(let z=0; z<e.touches.length; z++) {
          const i = e.touches[z].identifier
          const k = pointToKey(e.touches[z])
          if (k != null) down(k)
          tmap[i]=k
        }
        pd(e)
      }
      const move = e => {
        for(let z=0; z<e.touches.length; z++) {
          const i = e.touches[z].identifier
          const k = pointToKey(e.touches[z])
          if (tmap[i] == k) continue       // same cell, nothing to do.
          if (tmap[i] != null) up(tmap[i]) // release old key, if any
          if (k != null)       down(k)     // press new key, if any
          tmap[i]=k
        }
        pd(e)
      }
      const end = e => {
        for(let z=0; z<e.changedTouches.length; z++) {
          const i = e.changedTouches[z].identifier
          const k = pointToKey(e.changedTouches[z])
          if (tmap[i] != null) up(tmap[i])
          tmap[i]=null
        }
        pd(e)
      }
      screen.uninstallSeg16=addPointer(screen,start,move,end)
    },
    remove:  (screen) => {
      if(screen.uninstallSeg16)screen.uninstallSeg16()
      delete screen.uninstallSeg16
    },
  },

  /**
  * Provide a visible 4x4 representation of the VIP hex keypad.
  **/
  vip: {
    install: (screen,up,down,options) => {
      if (document.querySelector('.vip-pad')) return
      const root = document.createElement('div')
      root.classList.add('vip-pad')
      root.innerHTML = `<div class='keypad'>
        ${[0,1,2,3].map(r=>`<div>${[0,1,2,3].map(c=>`<div>${VIP_HEX[c+(r*4)].toUpperCase()}</div>`).join('')}</div>`).join('')}
      </div>
      <style>${VIP_STYLES}</style>`
      if (screen.parentElement == document.body) { screen.parentElement.append(root) }
      else { screen.parentElement.parentElement.append(root) }
      const buttons = []
      document.querySelectorAll('.vip-pad .keypad>div>div').forEach(x=>buttons.push(x)) // make an actual Array
      const held = {}
      const start = e => {
        for(let z=0; z<e.touches.length; z++) {
          const t = e.touches[z]
          const i = t.identifier
          const k = VIP_KEYS[buttons.indexOf(t.target)]
          t.target.classList.add('active')
          down(k)
          held[i]=k
        }
        pd(e)
      }
      const end = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (held[i] != undefined) { up(held[i]); delete held[i] }
          t.target.classList.remove('active')
        }
        pd(e)
      }
      buttons.forEach(b => addPointer(b,start,_=>{},end))
    },
    remove:  (screen) => {
      document.querySelector('.vip-pad').remove()
    },
  },
}

let adaptiveControlsInstalled = null

function injectAdaptiveControls(type, screen, keyup, keydown) {
  let options = {
    up:      5,
    down:    8,
    left:    7,
    right:   9,
    action1: 6,
    action2: 4,
    mode:    'center', // or 'fill', used by seg16
  }
  const lookup = vk => Object.keys(keymap[vk])[0]
  const install = _ => {
    rel(screen, 'touchstart', install)
    rel(screen, 'mousedown',  install)
    adaptiveControlsInstalled = type
    INPUT_MODULES[type].install(
      screen,
      key => keyup  ({ key:lookup(key), preventDefault:_=>_ }),
      key => keydown({ key:lookup(key), preventDefault:_=>_ }),
      options
    )
  }
  // uninstall anything that's already there:
  rel(screen, 'touchstart', install)
  rel(screen, 'mousedown' , install)
  if (adaptiveControlsInstalled) INPUT_MODULES[adaptiveControlsInstalled].remove(screen)

  if (type == 'none') return
  if (type == 'seg16fill') { type='seg16'; options.mode='fill' }
  if (type in {seg16:1,seg16fill:1}){
    install()
  }
  else {
    // defer installing adaptive input until we actually see
    // an input event from the user:
    ael(screen, 'touchstart', install)
    ael(screen, 'mousedown',  install)
  }
}
</script>
<body><canvas id='target' width=512 height=256></canvas></body>
<style>body{margin:0px;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;}</style>
<script>
const emulator = new Emulator()
unpackOptions(emulator, data.options)
setRenderTarget(data.options.displayScale || 4, 'target')
emulator.init({rom:data.rom})
emulator.importFlags = _ => getPref('octoFlagRegisters')
emulator.exportFlags = f => setPref('octoFlagRegisters',f)
try { localStorage.getItem('octoFlagRegisters') }
catch(e) {
	console.warn("Persistent flag register storage is unavailable! Flag registers will not be saved across sessions.")
	emulator.importFlags = _ => emulator.flags
	emulator.exportFlags = f => emulator.flags = f
}
emulator.buzzTrigger = (ticks,rest)=> playPattern(ticks, emulator.pattern, rest)
const kd = e=>{
	if (!audio) audioSetup(emulator)
	if (!(e.key in emulator.keys)) emulator.keys[e.key]=true
	e.preventDefault()
}
const ku = e=>{
	if (e.key in emulator.keys) delete emulator.keys[e.key]
	if (!emulator.waiting) return
	const kindex = keymapInverse[e.key]
	if (kindex != undefined) {
		emulator.waiting = false
		emulator.v[emulator.waitReg] = kindex
	}
	e.preventDefault()
}
window.addEventListener('keydown',kd,false)
window.addEventListener('keyup',ku,false)
const frameTime=1000/60
let last=Date.now(), origin=last+frameTime/2
intervalHandle=setInterval(_=>{
	last+=(Date.now()-last)
	if (emulator.halted) return
	for(var k=0; origin<last-frameTime&&k<2; origin+=frameTime,k++){
		for(var z=0;(z<emulator.tickrate) && (!emulator.waiting); z++){
			if (emulator.vBlankQuirks &&((emulator.m[emulator.pc] & 0xF0)==0xD0)) z=emulator.tickrate
			emulator.tick()
		}
		if (emulator.dt > 0) emulator.dt--
		if (emulator.st > 0) emulator.st--
		XOAudio && XOAudio.refresh(frameTime/1000)
	}
	renderDisplay(emulator)
	document.body.style.backgroundColor = emulator.st?emulator.buzzColor:emulator.quietColor
}, frameTime)
injectAdaptiveControls(emulator.touchInputMode,document.getElementById('target'),ku,kd)
</script>
